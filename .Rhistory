if (is.null(order.by.sample)==TRUE){combined <- combined[gene.order,]} #this is setting it, the order is determined in the loop, kind of redundant but dont feel like changing now
if (sum(groupings == FALSE, na.rm=T) !=0) {  ##if not grouped by samples, see if should be ordered by gene, set clustering of samples
if (is.null(order.by.gene)==FALSE){
if(is.raw.Ct==FALSE){combined <- combined[,order(combined[which(rownames(combined) %in% order.by.gene),],na.last = F)]}
if(is.raw.Ct==TRUE){combined <- combined[,order(combined[which(rownames(combined) %in% order.by.gene),],na.last = T)]}
clust.cols <- F
}else {
#clustering of samples
if (method %in% c("spearman","pearson", "kendall")) {
clust.samps<-(as.dist(1-cor(combined,method=method,use=NA.handling)))
}
if (method %in% c("euclidean","maximum","manhattan","canberra","binary","minkowski")){
clust.samps <- dist(t(combined), method=method)
}
}
gaps.col <- NULL
}
if(gaps.row==TRUE){
if (exists("factorgroupings.genes") == FALSE) {gaps.row <- gaps.row.n[-length(gaps.row.n)]} else{gaps.row <- gaps.groupings.genes}
gaps.row <- sort(rep(gaps.row,gap.width))}
clust.rows <- F
data.subset <- combined
}
#dealing with gaps and specific gaps of columns -- need to be able to set this for all scenarios
if(is.null(gaps.col.spec)==FALSE){gaps.col <- gaps.col.spec; gaps.col <- sort(rep(gaps.col, gap.width))}
if(is.null(gaps.row.spec)==FALSE){gaps.row <- gaps.row.spec; gaps.row <- sort(rep(gaps.row, gap.width))}
if(clust.rows==T){heightrow <- treeheight.row}
if(clust.cols==T){heightcol <- treeheight.col}
#fixing colors and breaks at the end, regardless of separations --- not going to be combined anymore
data.subset1 <- data.subset
data.subset <- scales::squish(data.subset,params$scale.range)
breaks <- seq(params$scale.range[1], params$scale.range[2],length.out=params$n.colors.range)
my_cols=colorRampPalette(params$scale.colors)(n=params$n.colors.range-1)
if(is.raw.Ct==TRUE){my_cols <- rev(my_cols)}
#na.fix, regardless of separations
if(na.fix==TRUE){
if(is.raw.Ct==TRUE){
data.subset[which(data.subset1==max(data.subset1))] <- params$scale.range[2]+0.04
breaks <- c(breaks, params$scale.range[2]+0.01, params$scale.range[2]+0.05)
my_cols <- c(my_cols,params$scale.colors[1],na.color)
}
if(is.raw.Ct==FALSE){
data.subset[which(data.subset1==min(data.subset1))] <- params$scale.range[1]-0.04
breaks <- c(params$scale.range[1]-0.05,params$scale.range[1]-0.01,breaks)
my_cols <- c(na.color,params$scale.colors[1],my_cols)
}
}
temp.annot_samps <- params$annot_samps
temp.annot_genes <- params$annot_genes
temp.annot_cols <- params$annot_cols
if (drop.annot.levels == TRUE) {
suppressWarnings( if (is.na(temp.annot_samps) == F) {
temp.annot_samps[] <- lapply(temp.annot_samps, as.factor)
#subset annot_samps and genes for subset so that annotations will be dropped in heatmap
temp.annot_samps <- temp.annot_samps %>% tibble::rownames_to_column("Sample")
temp.annot_samps <- droplevels(temp.annot_samps[which(temp.annot_samps$Sample %in% colnames(data.subset)),]) %>% as.data.frame() %>% tibble::remove_rownames() %>% tibble::column_to_rownames(var="Sample")
spec.cols <- colnames(temp.annot_samps)[colnames(temp.annot_samps) %in% names(temp.annot_cols)]
if (length(spec.cols) != 0 ) {
for (annot.i in 1:length(spec.cols)) {
annot <- colnames(temp.annot_samps)[annot.i]
temp.annot_cols[[which(names(temp.annot_cols)==annot)]] <- temp.annot_cols[[which(names(temp.annot_cols)==annot)]][which(   names(temp.annot_cols[[which(names(temp.annot_cols)==annot)]])   %in%   levels(temp.annot_samps[,which(colnames(temp.annot_samps)==annot)])  )]
if ( sum( levels(temp.annot_samps[,annot]) %in% names(temp.annot_cols[[which(names(temp.annot_cols)==annot)]])  ) != length(levels(temp.annot_samps[,annot]))) {
temp.annot_cols[[which(names(temp.annot_cols)==annot)]][c(levels(temp.annot_samps[,annot])[levels(temp.annot_samps[,annot]) %notin% names(temp.annot_cols[[which(names(temp.annot_cols)==annot)]])])] <- "white"
}
}
}
})
suppressWarnings( if (is.na(params$annot_genes) == F) {
temp.annot_genes[] <- lapply(temp.annot_genes, as.factor)
#subset annot_samps and genes for subset so that annotations will be dropped in heatmap
temp.annot_genes <- temp.annot_genes %>% tibble::rownames_to_column("Gene")
temp.annot_genes <- droplevels(temp.annot_genes[which(temp.annot_genes$Gene %in% rownames(data.subset)),]) %>% as.data.frame() %>% tibble::remove_rownames() %>% tibble::column_to_rownames(var="Gene")
spec.cols <- colnames(temp.annot_genes)[colnames(temp.annot_genes) %in% names(temp.annot_cols)]
if (length(spec.cols) != 0) {
for (annot.i in 1:length(colnames(temp.annot_genes))) {
annot <- colnames(temp.annot_genes)[annot.i]
if (length(which(names(temp.annot_cols)==annot)) != 0) {
temp.annot_cols[[which(names(temp.annot_cols)==annot)]] <- temp.annot_cols[[which(names(temp.annot_cols)==annot)]][which(   names(temp.annot_cols[[which(names(temp.annot_cols)==annot)]])   %in%   levels(temp.annot_genes[,which(colnames(temp.annot_genes)==annot)])  )]
if ( sum( levels(temp.annot_genes[,annot]) %in% names(temp.annot_cols[[which(names(temp.annot_cols)==annot)]])  ) != length(levels(temp.annot_genes[,annot]))) {
temp.annot_cols[[which(names(temp.annot_cols)==annot)]][c(levels(temp.annot_genes[,annot])[levels(temp.annot_genes[,annot]) %notin% names(temp.annot_cols[[which(names(temp.annot_cols)==annot)]])])] <- "white"
}
}
}
}
})
}
if (clust.cols == T) {
tryclustcols <- try(hclust(clust.samps, linkage), silent = T)
if (class(tryclustcols) == "try-error") {stop('cannot cluster columns, if too many NAs present, set na.fix = T to treat NA values as low expression instead of missing, otherwise set clust.cols = F or specify order.by.gene')}
}
if (clust.rows == T) {
tryclustrows <- try(hclust(clust.genes, linkage), silent = T)
if (class(tryclustrows) == "try-error") {stop('cannot cluster rows, if too many NAs present, set na.fix = T to treat NA values as low expression instead of missing, otherwise set clust.rows = F or specify order.by.sample')}
}
pheatmap(data.subset,col=my_cols, breaks=breaks, border_color = border.color, na_col = na.color, clustering_method=linkage,annotation_col=temp.annot_samps, annotation_colors = temp.annot_cols,
clustering_distance_rows = clust.genes, clustering_distance_cols = clust.samps, main=paste(main,"\n Method_",method,"_Linkage_",linkage),
cluster_rows = clust.rows, cluster_cols = clust.cols, cutree_rows = row.groups, cutree_cols = col.groups, gaps_row = gaps.row, gaps_col = gaps.col,fontsize_row = fontsize.row, fontsize_col = fontsize.col,
cellwidth = cell.width, cellheight = cell.height, show_rownames = show.rownames,show_colnames = show.colnames,
treeheight_row = heightrow ,treeheight_col = heightcol, silent=hide.plot, legend=show.legend, annotation_legend = show.annotations,
annotation_row=temp.annot_genes, drop_levels = drop.annot.levels, annotation_names_row = annotation.names.row, annotation_names_col = annotation.names.col)
}
myHeatmapByAnnotation1(NTS.stack.tog,temp.list , groupings = c("Age",  "Strain"),
groupings.gaps = c(0,2), annotation.names.row = FALSE, fontsize.row = 8, groupings.genes = "Temp_IDs")
set_annotations.genes(temp.genes)
set_annot_samps(c("Cell_Type","Temp_IDs"))
set_annot_samps(c("Cell_Type"))
set_annot_genes(c("Cell_Type"))
myHeatmapByAnnotation1(NTS.stack.tog,temp.list , groupings = c("Age",  "Strain"),
groupings.gaps = c(0,2), annotation.names.row = FALSE, fontsize.row = 8, groupings.genes = "Temp_IDs")
set_annot_samps(c("Region","Strain","Age"))
myHeatmapByAnnotation1(NTS.stack.tog,temp.list , groupings = c("Age",  "Strain"),
groupings.gaps = c(0,2), annotation.names.row = FALSE, fontsize.row = 8, groupings.genes = "Temp_IDs")
set_annot_genes(c("Cell_Type", "Temp_IDs"))
myHeatmapByAnnotation1(NTS.stack.tog,temp.list , groupings = c("Age",  "Strain"),
groupings.gaps = c(0,2), annotation.names.row = FALSE, fontsize.row = 8, groupings.genes = "Temp_IDs")
set_annot_genes1 <- function(annotations = NULL){
if (is.null(annotations) == TRUE) { params$annot_genes <<- params$annotations.genes
}else{
suppressWarnings( if (is.na(annotations)) { (params$annot_genes <<- NA)
}else{
if (sum(annotations %in% colnames(params$annotations.genes)) != length(annotations)) {
stop('one or more of the supplied list of annotations cannot be found in annotations.genes')
}
params$annot_genes <<- params$annotations.genes[,which(colnames(params$annotations.genes) %in% annotations),drop=FALSE]
params$annot_genes <<- params$annot_genes[,match(annotations, colnames(params$annot_genes)), drop = FALSE]
})
}
}
set_annot_genes1(c("Region","Strain","Age"))
myHeatmapByAnnotation1(NTS.stack.tog,temp.list , groupings = c("Age",  "Strain"),
groupings.gaps = c(0,2), annotation.names.row = FALSE, fontsize.row = 8, groupings.genes = "Temp_IDs", border.color = "white")
myHeatmapByAnnotation1(NTS.stack.tog,temp.list , groupings = c("Age",  "Strain"),
groupings.gaps = c(0,2), annotation.names.row = FALSE, fontsize.row = 8, groupings.genes = "Temp_IDs", border.color = "blue")
myHeatmapByAnnotation1(NTS.stack.tog,temp.list , groupings = c("Age",  "Strain"),
groupings.gaps = c(0,2), annotation.names.row = FALSE, fontsize.row = 8, groupings.genes = "Temp_IDs", border.color = "black")
?cor
?`networkD3-package`
?chordNetwork
myChord.region <- function(
list,
region , ##can also be time or WKY
order = c("WKY","Time","Strain"),
q.cut = 0.2,
FC.cut = 1.5,
exact = T,
fontsize = 12,
nodewidth = 30,
remove.all.zeros = TRUE,
remove.zero.vals = TRUE,
return.list = FALSE,
separate.persistent = TRUE,
iters = 0
){
all.compact <- read.table(paste0(prefix, "Dropbox (SBG)/SHR-Work/Integration/All_COMPACT_Assignments_Qval_", q.cut,"_FC_", FC.cut, ".txt"), sep = "\t", header = T)
if (exact == TRUE) {
if (length(grep("_", list)) == length(list)) {
subclusts <- all.compact[which(rownames(all.compact) %in% list),]#; rownames(dat.to.plot) <- colsplit(rownames(dat.to.plot),"_",c("ENS","Gene"))$Gene
}else{
subclusts <- all.compact[which(colsplit(rownames(all.compact),"_",c("ENS","Gene"))$Gene %in% list),];#rownames(dat.to.plot) <- colsplit(rownames(dat.to.plot),"_",c("ENS","Gene"))$Gene
}
}else{
subclusts <- all.compact[grep(paste(list, collapse="|"),rownames(all.compact)),]; #rownames(dat.to.plot) <- colsplit(rownames(dat.to.plot),"_",c("ENS","Gene"))$Gene
}
if (region == "NTS") {
compact <- subclusts[,c("NTS.WKY.ID", "NTS.SHR.Time.ID","NTS.SHR.Strain.ID")]
colnames(compact) <- c("WKY","Time","Strain")}
if (region == "RVLM") {
compact <- subclusts[,c("RVLM.WKY.ID", "RVLM.SHR.Time.ID","RVLM.SHR.Strain.ID")]
colnames(compact) <- c("WKY","Time","Strain")}
if (region == "CVLM") {
compact <- subclusts[,c("CVLM.WKY.ID", "CVLM.SHR.Time.ID","CVLM.SHR.Strain.ID")]
colnames(compact) <- c("WKY","Time","Strain")}
##SHR Strain
if (separate.persistent == TRUE) {
compact$Strain <- gsub("s-1-1-1-1-1","sneg", compact$Strain)
compact$Strain <- gsub("s11111","spos", compact$Strain)
}
compact$Strain <- gsub("s-1.*","s-1----", compact$Strain)
compact$Strain <- gsub("s0-1.*","s0-1---", compact$Strain)
compact$Strain <- gsub("s00-1.*","s00-1--", compact$Strain)
compact$Strain <- gsub("s000-1.*","s000-1-", compact$Strain)
compact$Strain <- gsub("s1.*","s1----", compact$Strain)
compact$Strain <- gsub("s01.*","s01---", compact$Strain)
compact$Strain <- gsub("s001.*","s001--", compact$Strain)
compact$Strain <- gsub("s0001.*","s0001-", compact$Strain)
if (separate.persistent == TRUE) {
compact$Strain <- gsub("sneg","s-1_across", compact$Strain)
compact$Strain <- gsub("spos","s1_across", compact$Strain)
}
compact$Strain[is.na(compact$Strain)] <- "s00000";
##SHR Time
compact$Time <- gsub("s-1.*","s-1---", compact$Time)
compact$Time <- gsub("s0-1.*","s0-1--", compact$Time)
compact$Time <- gsub("s00-1.*","s00-1-", compact$Time)
compact$Time <- gsub("s1.*","s1---", compact$Time)
compact$Time <- gsub("s01.*","s01--", compact$Time)
compact$Time <- gsub("s001.*","s001-", compact$Time)
compact$Time[is.na(compact$Time)] <- "s0000";
##WKY
compact$WKY <- gsub("w-1.*","w-1---", compact$WKY)
compact$WKY <- gsub("w0-1.*","w0-1--", compact$WKY)
compact$WKY <- gsub("w00-1.*","w00-1-", compact$WKY)
compact$WKY <- gsub("w1.*","w1---", compact$WKY)
compact$WKY <- gsub("w01.*","w01--", compact$WKY)
compact$WKY <- gsub("w001.*","w001-", compact$WKY)
compact$WKY[is.na(compact$WKY)] <- "w0000";
##get rid of things 0 across
if (remove.all.zeros == TRUE) {
if (length(which(compact$WKY == "w0000" & compact$Time == "s0000" & compact$Strain == "s00000")) != 0) {
compact <- compact[-which(compact$WKY == "w0000" & compact$Time == "s0000" & compact$Strain == "s00000"),]
}
}
compact <- compact[,order]
wky.order <- c("w1---","w01--","w001-","w0001","w0000",
"w-1---","w0-1--","w00-1-","w000-1")
WKY.names <-  unique(sort(compact$WKY))[match(wky.order, unique(sort(compact$WKY)))]
WKY.cols <- colorRampPalette(c("yellow","gray90","blue"))(length((WKY.names)))
WKY.cols <- WKY.cols[c(1:ceiling(length(WKY.cols)/2),length(WKY.cols):(ceiling(length(WKY.cols)/2)+1))]
time.order <- c("s1---","s01--","s001-","s0001","s0000",
"s-1---","s0-1--","s00-1-","s000-1")
Time.names <- unique(sort(compact$Time))[match(time.order, unique(sort(compact$Time)))]
Time.cols <- colorRampPalette(c("yellow","gray90","blue"))(length((Time.names)))
Time.cols <- Time.cols[c(1:ceiling(length(Time.cols)/2),length(Time.cols):(ceiling(length(Time.cols)/2)+1))]
if (separate.persistent == TRUE) {
strain.order <- c("s1_across","s1----","s01---","s001--","s0001-","s00001","s00000",
"s-1_across","s-1----","s0-1---","s00-1--","s000-1-","s0000-1")
Strain.names <- unique(sort(compact$Strain))[match(strain.order, unique(sort(compact$Strain)))]
}else{
strain.order <- c("s1----","s01---","s001--","s0001-","s00001","s00000",
"s-1----","s0-1---","s00-1--","s000-1-","s0000-1")
Strain.names <- unique(sort(compact$Strain))[match(strain.order, unique(sort(compact$Strain)))]
}
Strain.cols <- colorRampPalette(c("yellow","gray90","blue"))(length((Strain.names)))
Strain.cols <- Strain.cols[c(1:ceiling(length(Strain.cols)/2),length(Strain.cols):(ceiling(length(Strain.cols)/2)+1))]
names.all <- c( eval(parse(text = paste0(order[1],".names"))),eval(parse(text = paste0(order[2],".names"))), eval(parse(text = paste0(order[3],".names")))   )
cols <- c( eval(parse(text = paste0(order[1],".cols"))),eval(parse(text = paste0(order[2],".cols"))), eval(parse(text = paste0(order[3],".cols")))   )
if (length(which(is.na(names.all))) != 0 ) {
names <- names.all[-which(is.na(names.all))]
cols <- cols[-which(is.na(names.all))]
}else{names <- names.all}
my_color <- paste('d3.scaleOrdinal() .domain([',paste0('"', paste(names, collapse='", "'), '"'), ']) .range([',paste0('"', paste(cols, collapse='", "'), '"'), '])')
nodes <- data.frame("name"=names,
"type"= c(rep(colnames(compact)[1], (length(unique(compact[,1])))),
rep(colnames(compact)[2], (length(unique(compact[,2])))),
rep(colnames(compact)[3], (length(unique(compact[,3]))))),
"groups" = names)
#suppressMessages( new.compact <- apply(compact,2,function(x)(mapvalues(x, from = names, to = 0:(length(names)-1)))) %>% as.data.frame() )
table1 <- table(new.compact[,1], new.compact[,2]) %>% melt(); #table1$Group <- "NTS > RVLM"
table2 <- table(new.compact[,2], new.compact[,3]) %>% melt(); #table2$Group <- "RVLM > CVLM"
table.extra <- table(new.compact[,1], new.compact[,3]) %>% melt(); #table.extra$Group <- "NTS > CVLM"
#links.table <- rbind(table1, table2); names(links.table) <- c("source","target","value")
links.table <- rbind(table1, table2, table.extra); names(links.table) <- c("source","target","value")
links.matrix <- dcast(links.table)
if (remove.zero.vals == TRUE) {
if (length(which(links.table$value == 0))!= 0) {
links.table <- links.table[-which(links.table$value == 0),]
}
}
if (return.list == TRUE) {
return(compact) }
chordNetwork(links.matrix)#,
#LinkGroup = "group", NodeGroup = "node.group")
}
myChord.region(rownames(all.compact.1.5), "NTS")
myChord.region <- function(
list,
region , ##can also be time or WKY
order = c("WKY","Time","Strain"),
q.cut = 0.2,
FC.cut = 1.5,
exact = T,
fontsize = 12,
nodewidth = 30,
remove.all.zeros = TRUE,
remove.zero.vals = TRUE,
return.list = FALSE,
separate.persistent = TRUE,
iters = 0
){
all.compact <- read.table(paste0(prefix, "Dropbox (SBG)/SHR-Work/Integration/All_COMPACT_Assignments_Qval_", q.cut,"_FC_", FC.cut, ".txt"), sep = "\t", header = T)
if (exact == TRUE) {
if (length(grep("_", list)) == length(list)) {
subclusts <- all.compact[which(rownames(all.compact) %in% list),]#; rownames(dat.to.plot) <- colsplit(rownames(dat.to.plot),"_",c("ENS","Gene"))$Gene
}else{
subclusts <- all.compact[which(colsplit(rownames(all.compact),"_",c("ENS","Gene"))$Gene %in% list),];#rownames(dat.to.plot) <- colsplit(rownames(dat.to.plot),"_",c("ENS","Gene"))$Gene
}
}else{
subclusts <- all.compact[grep(paste(list, collapse="|"),rownames(all.compact)),]; #rownames(dat.to.plot) <- colsplit(rownames(dat.to.plot),"_",c("ENS","Gene"))$Gene
}
if (region == "NTS") {
compact <- subclusts[,c("NTS.WKY.ID", "NTS.SHR.Time.ID","NTS.SHR.Strain.ID")]
colnames(compact) <- c("WKY","Time","Strain")}
if (region == "RVLM") {
compact <- subclusts[,c("RVLM.WKY.ID", "RVLM.SHR.Time.ID","RVLM.SHR.Strain.ID")]
colnames(compact) <- c("WKY","Time","Strain")}
if (region == "CVLM") {
compact <- subclusts[,c("CVLM.WKY.ID", "CVLM.SHR.Time.ID","CVLM.SHR.Strain.ID")]
colnames(compact) <- c("WKY","Time","Strain")}
##SHR Strain
if (separate.persistent == TRUE) {
compact$Strain <- gsub("s-1-1-1-1-1","sneg", compact$Strain)
compact$Strain <- gsub("s11111","spos", compact$Strain)
}
compact$Strain <- gsub("s-1.*","s-1----", compact$Strain)
compact$Strain <- gsub("s0-1.*","s0-1---", compact$Strain)
compact$Strain <- gsub("s00-1.*","s00-1--", compact$Strain)
compact$Strain <- gsub("s000-1.*","s000-1-", compact$Strain)
compact$Strain <- gsub("s1.*","s1----", compact$Strain)
compact$Strain <- gsub("s01.*","s01---", compact$Strain)
compact$Strain <- gsub("s001.*","s001--", compact$Strain)
compact$Strain <- gsub("s0001.*","s0001-", compact$Strain)
if (separate.persistent == TRUE) {
compact$Strain <- gsub("sneg","s-1_across", compact$Strain)
compact$Strain <- gsub("spos","s1_across", compact$Strain)
}
compact$Strain[is.na(compact$Strain)] <- "s00000";
##SHR Time
compact$Time <- gsub("s-1.*","s-1---", compact$Time)
compact$Time <- gsub("s0-1.*","s0-1--", compact$Time)
compact$Time <- gsub("s00-1.*","s00-1-", compact$Time)
compact$Time <- gsub("s1.*","s1---", compact$Time)
compact$Time <- gsub("s01.*","s01--", compact$Time)
compact$Time <- gsub("s001.*","s001-", compact$Time)
compact$Time[is.na(compact$Time)] <- "s0000";
##WKY
compact$WKY <- gsub("w-1.*","w-1---", compact$WKY)
compact$WKY <- gsub("w0-1.*","w0-1--", compact$WKY)
compact$WKY <- gsub("w00-1.*","w00-1-", compact$WKY)
compact$WKY <- gsub("w1.*","w1---", compact$WKY)
compact$WKY <- gsub("w01.*","w01--", compact$WKY)
compact$WKY <- gsub("w001.*","w001-", compact$WKY)
compact$WKY[is.na(compact$WKY)] <- "w0000";
##get rid of things 0 across
if (remove.all.zeros == TRUE) {
if (length(which(compact$WKY == "w0000" & compact$Time == "s0000" & compact$Strain == "s00000")) != 0) {
compact <- compact[-which(compact$WKY == "w0000" & compact$Time == "s0000" & compact$Strain == "s00000"),]
}
}
compact <- compact[,order]
wky.order <- c("w1---","w01--","w001-","w0001","w0000",
"w-1---","w0-1--","w00-1-","w000-1")
WKY.names <-  unique(sort(compact$WKY))[match(wky.order, unique(sort(compact$WKY)))]
WKY.cols <- colorRampPalette(c("yellow","gray90","blue"))(length((WKY.names)))
WKY.cols <- WKY.cols[c(1:ceiling(length(WKY.cols)/2),length(WKY.cols):(ceiling(length(WKY.cols)/2)+1))]
time.order <- c("s1---","s01--","s001-","s0001","s0000",
"s-1---","s0-1--","s00-1-","s000-1")
Time.names <- unique(sort(compact$Time))[match(time.order, unique(sort(compact$Time)))]
Time.cols <- colorRampPalette(c("yellow","gray90","blue"))(length((Time.names)))
Time.cols <- Time.cols[c(1:ceiling(length(Time.cols)/2),length(Time.cols):(ceiling(length(Time.cols)/2)+1))]
if (separate.persistent == TRUE) {
strain.order <- c("s1_across","s1----","s01---","s001--","s0001-","s00001","s00000",
"s-1_across","s-1----","s0-1---","s00-1--","s000-1-","s0000-1")
Strain.names <- unique(sort(compact$Strain))[match(strain.order, unique(sort(compact$Strain)))]
}else{
strain.order <- c("s1----","s01---","s001--","s0001-","s00001","s00000",
"s-1----","s0-1---","s00-1--","s000-1-","s0000-1")
Strain.names <- unique(sort(compact$Strain))[match(strain.order, unique(sort(compact$Strain)))]
}
Strain.cols <- colorRampPalette(c("yellow","gray90","blue"))(length((Strain.names)))
Strain.cols <- Strain.cols[c(1:ceiling(length(Strain.cols)/2),length(Strain.cols):(ceiling(length(Strain.cols)/2)+1))]
names.all <- c( eval(parse(text = paste0(order[1],".names"))),eval(parse(text = paste0(order[2],".names"))), eval(parse(text = paste0(order[3],".names")))   )
cols <- c( eval(parse(text = paste0(order[1],".cols"))),eval(parse(text = paste0(order[2],".cols"))), eval(parse(text = paste0(order[3],".cols")))   )
if (length(which(is.na(names.all))) != 0 ) {
names <- names.all[-which(is.na(names.all))]
cols <- cols[-which(is.na(names.all))]
}else{names <- names.all}
my_color <- paste('d3.scaleOrdinal() .domain([',paste0('"', paste(names, collapse='", "'), '"'), ']) .range([',paste0('"', paste(cols, collapse='", "'), '"'), '])')
nodes <- data.frame("name"=names,
"type"= c(rep(colnames(compact)[1], (length(unique(compact[,1])))),
rep(colnames(compact)[2], (length(unique(compact[,2])))),
rep(colnames(compact)[3], (length(unique(compact[,3]))))),
"groups" = names)
#suppressMessages( new.compact <- apply(compact,2,function(x)(mapvalues(x, from = names, to = 0:(length(names)-1)))) %>% as.data.frame() )
new.compact <- compact
table1 <- table(new.compact[,1], new.compact[,2]) %>% melt(); #table1$Group <- "NTS > RVLM"
table2 <- table(new.compact[,2], new.compact[,3]) %>% melt(); #table2$Group <- "RVLM > CVLM"
table.extra <- table(new.compact[,1], new.compact[,3]) %>% melt(); #table.extra$Group <- "NTS > CVLM"
#links.table <- rbind(table1, table2); names(links.table) <- c("source","target","value")
links.table <- rbind(table1, table2, table.extra); names(links.table) <- c("source","target","value")
links.matrix <- dcast(links.table)
if (remove.zero.vals == TRUE) {
if (length(which(links.table$value == 0))!= 0) {
links.table <- links.table[-which(links.table$value == 0),]
}
}
if (return.list == TRUE) {
return(compact) }
chordNetwork(links.matrix)#,
#LinkGroup = "group", NodeGroup = "node.group")
}
myChord.region(rownames(all.compact.1.5), "NTS")
all.compact <- all.compact.1.5
list <- rownames(all.compact.1.5)
subclusts <- all.compact[which(rownames(all.compact) %in% list),]#; rownames(dat.to.plot) <- colsplit(rownames(dat.to.plot),"_",c("ENS","Gene"))$Gene
compact <- subclusts[,c("NTS.WKY.ID", "NTS.SHR.Time.ID","NTS.SHR.Strain.ID")]
colnames(compact) <- c("WKY","Time","Strain")}
colnames(compact) <- c("WKY","Time","Strain")
compact$Strain <- gsub("s-1-1-1-1-1","sneg", compact$Strain)
compact$Strain <- gsub("s11111","spos", compact$Strain)
compact$Strain <- gsub("s-1.*","s-1----", compact$Strain)
compact$Strain <- gsub("s0-1.*","s0-1---", compact$Strain)
compact$Strain <- gsub("s00-1.*","s00-1--", compact$Strain)
compact$Strain <- gsub("s000-1.*","s000-1-", compact$Strain)
compact$Strain <- gsub("s1.*","s1----", compact$Strain)
compact$Strain <- gsub("s01.*","s01---", compact$Strain)
compact$Strain <- gsub("s001.*","s001--", compact$Strain)
compact$Strain <- gsub("s0001.*","s0001-", compact$Strain)
compact$Strain <- gsub("sneg","s-1_across", compact$Strain)
compact$Strain <- gsub("spos","s1_across", compact$Strain)
compact$Strain[is.na(compact$Strain)] <- "s00000";
##SHR Time
compact$Time <- gsub("s-1.*","s-1---", compact$Time)
compact$Time <- gsub("s0-1.*","s0-1--", compact$Time)
compact$Time <- gsub("s00-1.*","s00-1-", compact$Time)
compact$Time <- gsub("s1.*","s1---", compact$Time)
compact$Time <- gsub("s01.*","s01--", compact$Time)
compact$Time <- gsub("s001.*","s001-", compact$Time)
compact$Time[is.na(compact$Time)] <- "s0000";
##WKY
compact$WKY <- gsub("w-1.*","w-1---", compact$WKY)
compact$WKY <- gsub("w0-1.*","w0-1--", compact$WKY)
compact$WKY <- gsub("w00-1.*","w00-1-", compact$WKY)
compact$WKY <- gsub("w1.*","w1---", compact$WKY)
compact$WKY <- gsub("w01.*","w01--", compact$WKY)
compact$WKY <- gsub("w001.*","w001-", compact$WKY)
compact$WKY[is.na(compact$WKY)] <- "w0000";
##get rid of things 0 across
if (remove.all.zeros == TRUE) {
if (length(which(compact$WKY == "w0000" & compact$Time == "s0000" & compact$Strain == "s00000")) != 0) {
compact <- compact[-which(compact$WKY == "w0000" & compact$Time == "s0000" & compact$Strain == "s00000"),]
}
}
if (length(which(compact$WKY == "w0000" & compact$Time == "s0000" & compact$Strain == "s00000")) != 0) {
compact <- compact[-which(compact$WKY == "w0000" & compact$Time == "s0000" & compact$Strain == "s00000"),]
}
wky.order <- c("w1---","w01--","w001-","w0001","w0000",
"w-1---","w0-1--","w00-1-","w000-1")
WKY.names <-  unique(sort(compact$WKY))[match(wky.order, unique(sort(compact$WKY)))]
WKY.cols <- colorRampPalette(c("yellow","gray90","blue"))(length((WKY.names)))
WKY.cols <- WKY.cols[c(1:ceiling(length(WKY.cols)/2),length(WKY.cols):(ceiling(length(WKY.cols)/2)+1))]
time.order <- c("s1---","s01--","s001-","s0001","s0000",
"s-1---","s0-1--","s00-1-","s000-1")
Time.names <- unique(sort(compact$Time))[match(time.order, unique(sort(compact$Time)))]
Time.cols <- colorRampPalette(c("yellow","gray90","blue"))(length((Time.names)))
Time.cols <- Time.cols[c(1:ceiling(length(Time.cols)/2),length(Time.cols):(ceiling(length(Time.cols)/2)+1))]
strain.order <- c("s1_across","s1----","s01---","s001--","s0001-","s00001","s00000",
"s-1_across","s-1----","s0-1---","s00-1--","s000-1-","s0000-1")
Strain.names <- unique(sort(compact$Strain))[match(strain.order, unique(sort(compact$Strain)))]
Strain.cols <- colorRampPalette(c("yellow","gray90","blue"))(length((Strain.names)))
Strain.cols <- Strain.cols[c(1:ceiling(length(Strain.cols)/2),length(Strain.cols):(ceiling(length(Strain.cols)/2)+1))]
names.all <- c( eval(parse(text = paste0(order[1],".names"))),eval(parse(text = paste0(order[2],".names"))), eval(parse(text = paste0(order[3],".names")))   )
cols <- c( eval(parse(text = paste0(order[1],".cols"))),eval(parse(text = paste0(order[2],".cols"))), eval(parse(text = paste0(order[3],".cols")))   )
#suppressMessages( new.compact <- apply(compact,2,function(x)(mapvalues(x, from = names, to = 0:(length(names)-1)))) %>% as.data.frame() )
new.compact <- compact
table1 <- table(new.compact[,1], new.compact[,2]) %>% melt(); #table1$Group <- "NTS > RVLM"
table2 <- table(new.compact[,2], new.compact[,3]) %>% melt(); #table2$Group <- "RVLM > CVLM"
table.extra <- table(new.compact[,1], new.compact[,3]) %>% melt(); #table.extra$Group <- "NTS > CVLM"
#links.table <- rbind(table1, table2); names(links.table) <- c("source","target","value")
links.table <- rbind(table1, table2, table.extra); names(links.table) <- c("source","target","value")
links.matrix <- dcast(links.table)
head(links.matrix)
head(links.table)
links.matrix <- dcast(links.table, source~target)
head(links.matrix)
chordNetwork(links.matrix)#,
head(compact)
?dcast
links.matrix <- dcast(links.table, source~target, drop = FALSE)
links.matrix <- dcast(links.table, source~target, drop = FALSE, fill = 0)
length(unique(links.table$source))
length(unique(links.table$target))
links.matrix <- dcast(links.table, value.var = "value" , drop = FALSE, fill = 0)
links.matrix <- dcast(links.table, target~source, drop = FALSE, fill = 0)
sources <- length(unique(links.table$source))
targets <- length(unique(links.table$target))
sources[sources %notin% targets]
sources
targets <- (unique(links.table$target))
sources <- (unique(links.table$source))
sources[sources %notin% targets]
table1 <- table(new.compact[,1], new.compact[,2]) %>% melt(); #table1$Group <- "NTS > RVLM"
table2 <- table(new.compact[,2], new.compact[,3]) %>% melt(); #table2$Group <- "RVLM > CVLM"
table.extra <- table(new.compact[,3], new.compact[,1]) %>% melt(); #table.extra$Group <- "NTS > CVLM"
#links.table <- rbind(table1, table2); names(links.table) <- c("source","target","value")
links.table <- rbind(table1, table2, table.extra); names(links.table) <- c("source","target","value")
links.matrix <- dcast(links.table, target~source, drop = FALSE, fill = 0)
head(links.matrix)
links.matrix <- dcast(links.table, target~source)
links.matrix <- acast(links.table, target~source)
head(links.matrix)
chordNetwork(links.matrix)#,
sum(rownames(links.matrix)==colnames(links.matrix))
rownames(links.matrix)
colnames(links.matrix)
chordNetwork(links.matrix, labels = rownames(links.matrix))#,
?chordNetworkOutput
install.packages("chorddiag")
devtools::install_github("mattflor/chorddiag")
devtools::install_github("mattflor/chorddiag")
install.packages("rlang")
devtools::install_github("mattflor/chorddiag")
install.packages("rlang")
devtools::install_github("mattflor/chorddiag")
library(rlang)
update.packages(rlang)
update.packages("rlang")
library(rlang)
install.packages("rlang")
library(dataVisEasy)
library(dataVisEasy)
?full_join
library(dataVisEasy)
